/// <reference types="node" />
import { KeyType } from './KeyType';
import { KeyUse } from './KeyUse';
import { KeyExport } from './KeyExport';
/**
 * Class to model a key
 */
export default class DidKey {
    private _keyType;
    private _keyUse;
    private _algorithm;
    private _crypto;
    private _exportable;
    private _rawKey;
    private _jwkKeys;
    private _keyObjects;
    private _didMasterKeys;
    private _didPairwiseKeys;
    /**
     * Create an instance of DidKey.
     * @param crypto The crypto object.
     * @param algorithm Intended algorithm to use for the key.
     * @param key The key.
     * @param exportable True if the key is exportable.
     */
    constructor(crypto: any, algorithm: any, key?: any, exportable?: boolean);
    /**
     * Gets the key use.
     */
    readonly keyUse: KeyUse;
    /**
     * Gets the key type.
     */
    readonly keyType: KeyType;
    /**
     * Gets the intended algorithm to use for the key.
     */
    readonly algorithm: any;
    /**
     * Gets the exportable property of the key indicating whether the app can extract the key.
     */
    readonly exportable: boolean;
    /**
     * Gets the key in jwk format.
     */
    getJwkKey(keyExport: KeyExport): Promise<any>;
    /**
     * Sign the data with the current key
     * @param data  Data to be signed with the current key
     */
    sign(data: Buffer): Promise<ArrayBuffer>;
    /**
     * Sign the data with the current key
     * @param data  The data signed with the current key
     * @param signature  The signature on the data
     */
    verify(data: Buffer, signature: ArrayBuffer): Promise<boolean>;
    /**
     * Generate a pairwise key
     * @param seed  The master seed for generating pairwise keys
     * @param did  The owner DID
     * @param peerId  The representation of the peer
     */
    generatePairwise(seed: Buffer, did: string, peerId: string): Promise<DidKey>;
    /**
     * Normalize the algorithm so it can be used by underlying crypto.
     * @param algorithm Algorithm to be normalized
     */
    static normalizeAlgorithm(algorithm: any): any;
    /**
     * Normalize the jwk so it can be used by underlying crypto.
     * @param jwk Json web key to be normalized
     */
    static normalizeJwk(jwk: any): any;
    private mapDidPairwiseKeys;
    private readonly isKeyPair;
    /**
     * Generate a pairwise did master key.
     * @param seed  The master seed for generating pairwise keys
     * @param did  The owner DID
     * @param peerId  The representation of the peer
     */
    private generateDidMasterKey;
    private setKeyUsage;
    private getJwkKeyFromKeyObject;
    private getOctJwkKey;
    private getKeyPairJwkKey;
    private getKeyIdentifier;
    private getJwkKeyFromCache;
    private cacheJwkKey;
    private getKeyObject;
    private cacheKeyObject;
    private getOrGenerateKey;
    private setFromRawKey;
    private generateOctKey;
    private generateKeyPair;
}
