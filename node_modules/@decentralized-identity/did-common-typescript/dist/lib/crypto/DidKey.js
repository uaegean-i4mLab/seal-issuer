"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const KeyType_1 = __importStar(require("./KeyType"));
const KeyUse_1 = __importStar(require("./KeyUse"));
const KeyObject_1 = __importDefault(require("./KeyObject"));
const PairwiseKey_1 = __importDefault(require("./PairwiseKey"));
const MasterKey_1 = __importDefault(require("./MasterKey"));
const base64url_1 = __importDefault(require("base64url"));
const KeyExport_1 = require("./KeyExport");
const clone = require('clone');
/**
 * Class to model a key
 */
class DidKey {
    /**
     * Create an instance of DidKey.
     * @param crypto The crypto object.
     * @param algorithm Intended algorithm to use for the key.
     * @param key The key.
     * @param exportable True if the key is exportable.
     */
    constructor(crypto, algorithm, key = undefined, exportable = true) {
        // Store for jwk keys in different formats. This is the format returned by exportKey
        this._jwkKeys = new Map();
        // Store key objects. This is the format returned by generateKey
        this._keyObjects = new Map();
        // Set of master keys
        this._didMasterKeys = [];
        // Set of pairwise keys
        this._didPairwiseKeys = new Map();
        this._crypto = crypto;
        // Check algorithm
        if (!algorithm.name) {
            throw new Error('Missing property name in algorithm');
        }
        this._keyUse = KeyUse_1.default.create(algorithm);
        this._keyType = KeyType_1.default.create(algorithm);
        this._exportable = exportable;
        this._algorithm = algorithm;
        // Set the raw key. Can be null if the key needs to be generated
        this._rawKey = key;
    }
    /**
     * Gets the key use.
     */
    get keyUse() {
        return this._keyUse;
    }
    /**
     * Gets the key type.
     */
    get keyType() {
        return this._keyType;
    }
    /**
     * Gets the intended algorithm to use for the key.
     */
    get algorithm() {
        return this._algorithm;
    }
    /**
     * Gets the exportable property of the key indicating whether the app can extract the key.
     */
    get exportable() {
        return this._exportable;
    }
    /**
     * Gets the key in jwk format.
     */
    async getJwkKey(keyExport) {
        // check if key is already cached
        let keyId = this.getKeyIdentifier(this.keyType, this.keyUse, keyExport);
        let jwkKey = this.getJwkKeyFromCache(keyId);
        if (jwkKey) {
            // Return the key if it already exists
            return jwkKey;
        }
        // Get the key or generate the key if needed
        let keyObject = await this.getOrGenerateKey();
        // Cache the key object
        this.cacheKeyObject(keyId, keyObject);
        // export to jwk format
        let jwk = await this.getJwkKeyFromKeyObject(keyExport, keyObject);
        // Save jwk format
        this.cacheJwkKey(keyId, jwk);
        // Check to save public key
        if (this.isKeyPair && keyExport === KeyExport_1.KeyExport.Private) {
            // Save only public key
            let jwkPublic = {};
            jwkPublic.kty = jwk.kty;
            jwkPublic.use = jwk.use;
            jwkPublic.key_ops = jwk.key_ops;
            if (this.keyType === KeyType_1.KeyType.RSA) {
                jwkPublic.e = jwk.e;
                jwkPublic.n = jwk.n;
            }
            else {
                jwkPublic.crv = jwk.crv;
                jwkPublic.x = jwk.x;
                jwkPublic.y = jwk.y;
            }
            // Save public key
            let keyIdPublick = this.getKeyIdentifier(this.keyType, this.keyUse, KeyExport_1.KeyExport.Public);
            this.cacheJwkKey(keyIdPublick, jwkPublic);
            let keyObject = await this._crypto.subtle
                .importKey('jwk', DidKey.normalizeJwk(jwkPublic), DidKey.normalizeAlgorithm(this._algorithm), this._exportable, this.setKeyUsage());
            this.cacheKeyObject(keyIdPublick, new KeyObject_1.default(this.keyType, keyObject));
        }
        return jwk;
    }
    /**
     * Sign the data with the current key
     * @param data  Data to be signed with the current key
     */
    async sign(data) {
        let keyExport = this.isKeyPair ? KeyExport_1.KeyExport.Private : KeyExport_1.KeyExport.Secret;
        let keyId = this.getKeyIdentifier(this.keyType, this.keyUse, keyExport);
        // console.log(`Sign data: ${base64url(data)} with ${keyId}`);
        await this.getJwkKey(keyExport);
        let keyObject = this.getKeyObject(keyId);
        if (keyObject) {
            return this._crypto.subtle
                .sign(DidKey.normalizeAlgorithm(this._algorithm), this.isKeyPair ? keyObject.privateKey : keyObject.secretKey, data);
        }
        else {
            throw new Error(`No private key for signature: ${keyId}`);
        }
    }
    /**
     * Sign the data with the current key
     * @param data  The data signed with the current key
     * @param signature  The signature on the data
     */
    async verify(data, signature) {
        // console.log(`Verify data: ${base64url(data)}`);
        let keyExport = this.isKeyPair ? KeyExport_1.KeyExport.Public : KeyExport_1.KeyExport.Secret;
        let jwk = await this.getJwkKey(keyExport);
        jwk.key_ops = ['verify'];
        let keyObject = await this._crypto.subtle
            .importKey('jwk', DidKey.normalizeJwk(jwk), DidKey.normalizeAlgorithm(this._algorithm), this._exportable, this.setKeyUsage());
        return this._crypto.subtle.verify(DidKey.normalizeAlgorithm(this._algorithm), keyObject, signature, data);
    }
    /**
     * Generate a pairwise key
     * @param seed  The master seed for generating pairwise keys
     * @param did  The owner DID
     * @param peerId  The representation of the peer
     */
    async generatePairwise(seed, did, peerId) {
        let pairwiseDidKey;
        let didMasterKey = await this.generateDidMasterKey(seed, did);
        let pairwise = this._didPairwiseKeys.get(this.mapDidPairwiseKeys(did, peerId));
        if (pairwise) {
            return pairwise;
        }
        switch (this._keyType) {
            case KeyType_1.KeyType.EC:
            case KeyType_1.KeyType.RSA:
                // Generate new pairwise key
                const pairwiseKey = new PairwiseKey_1.default(did, peerId);
                pairwiseDidKey = await pairwiseKey.generate(didMasterKey.key, this._crypto, this._algorithm, this._keyType, this._keyUse, this._exportable);
                // Cache pairwise key
                this._didPairwiseKeys.set(this.mapDidPairwiseKeys(did, peerId), pairwiseDidKey);
                break;
            default:
                throw new Error(`Pairwise key for type '${this._keyType}' is not supported.`);
        }
        // Store private and public key.
        await pairwiseDidKey.getJwkKey(KeyExport_1.KeyExport.Private);
        return pairwiseDidKey;
    }
    /**
     * Normalize the algorithm so it can be used by underlying crypto.
     * @param algorithm Algorithm to be normalized
     */
    static normalizeAlgorithm(algorithm) {
        if (algorithm.namedCurve) {
            if (algorithm.namedCurve === 'P-256K') {
                let alg = clone(algorithm);
                alg.namedCurve = 'K-256';
                return alg;
            }
        }
        return algorithm;
    }
    /**
     * Normalize the jwk so it can be used by underlying crypto.
     * @param jwk Json web key to be normalized
     */
    static normalizeJwk(jwk) {
        if (jwk.crv) {
            if (jwk.crv === 'P-256K') {
                let key = clone(jwk);
                key.crv = 'K-256';
                return key;
            }
        }
        return jwk;
    }
    // Generate a unique key id for storage of pairwise keys
    mapDidPairwiseKeys(did, peerId) {
        // TODO add key use if we want different keys for signing and encryption
        return `${this._keyType}_${did}_${peerId}`;
    }
    // True if the key is a key pair
    get isKeyPair() {
        return this._keyType === KeyType_1.KeyType.EC || this._keyType === KeyType_1.KeyType.RSA;
    }
    /**
     * Generate a pairwise did master key.
     * @param seed  The master seed for generating pairwise keys
     * @param did  The owner DID
     * @param peerId  The representation of the peer
     */
    async generateDidMasterKey(seed, did) {
        let mk = undefined;
        // Check if key was already generated
        this._didMasterKeys.forEach((masterKey) => {
            if (masterKey.did === did) {
                mk = masterKey;
                return;
            }
        });
        if (mk) {
            return mk;
        }
        let alg = { name: 'hmac', hash: 'SHA-512' };
        let signKey = new DidKey(this._crypto, alg, seed);
        await signKey.getJwkKey(KeyExport_1.KeyExport.Secret);
        let signature = await signKey.sign(Buffer.from(did));
        mk = new MasterKey_1.default(did, Buffer.from(signature));
        this._didMasterKeys.push(mk);
        return mk;
    }
    // Set keyUsage
    setKeyUsage() {
        switch (this._keyUse) {
            case KeyUse_1.KeyUse.Encryption:
                if (this.isKeyPair) {
                    return ['deriveKey', 'deriveBits'];
                }
                return ['encrypt', 'decrypt'];
            case KeyUse_1.KeyUse.Signature:
                return ['sign', 'verify'];
        }
        throw new Error(`The value for KeyUse '${this._keyUse}' is invalid. Needs to be sig or enc`);
    }
    // Transform the KeyObject into a JWK key
    async getJwkKeyFromKeyObject(keyExport, keyObject) {
        if (!keyObject) {
            throw new Error('keyObject argument in getJwkKey cannot be null');
        }
        switch (this._keyType) {
            case KeyType_1.KeyType.Oct:
                return this.getOctJwkKey(keyObject);
            case KeyType_1.KeyType.RSA:
            case KeyType_1.KeyType.EC:
                return this.getKeyPairJwkKey(keyExport, keyObject);
        }
        throw new Error(`DidKey:getJwkKey->${this._keyType} is not supported`);
    }
    // Transform the oct KeyObject into a JWK key.
    async getOctJwkKey(keyObject) {
        let jwk = await this._crypto.subtle.exportKey('jwk', keyObject.secretKey);
        return jwk;
    }
    // Transform the key pair KeyObject into a JWK key.
    async getKeyPairJwkKey(keyExport, keyObject) {
        let nativeKey = undefined;
        switch (keyExport) {
            case KeyExport_1.KeyExport.Private:
                nativeKey = keyObject.privateKey;
                break;
            case KeyExport_1.KeyExport.Public:
                nativeKey = keyObject.publicKey;
                break;
        }
        let jwk = await this._crypto.subtle.exportKey('jwk', nativeKey);
        return jwk;
    }
    getKeyIdentifier(keyType, keyUse, keyExport) {
        return `${keyType}-${keyUse}-${keyExport}`;
    }
    getJwkKeyFromCache(keyId) {
        // TODO add decryption with a system key
        return this._jwkKeys.get(keyId);
    }
    cacheJwkKey(keyId, jwk) {
        // TODO add encryption with a system key
        this._jwkKeys.set(keyId, jwk);
        return true;
    }
    getKeyObject(keyId) {
        // TODO add decryption with a system key
        return this._keyObjects.get(keyId);
    }
    cacheKeyObject(keyId, jwk) {
        // TODO add encryption with a system key
        this._keyObjects.set(keyId, jwk);
        return true;
    }
    // Get the key or generate the key if needed
    // Return a keyObject
    async getOrGenerateKey() {
        if (this._rawKey === null) {
            // indicate key is generated and raw key was not set by caller
            this._rawKey = undefined;
            // key generation required
            switch (this.keyType) {
                case KeyType_1.KeyType.EC:
                case KeyType_1.KeyType.RSA:
                    return this.generateKeyPair();
                case KeyType_1.KeyType.Oct:
                    return this.generateOctKey();
                default:
                    throw new Error(`Key type '${this.keyType}' not supported`);
            }
        }
        else
            return this.setFromRawKey(this._rawKey);
    }
    // Generate KeyObject from raw key
    async setFromRawKey(key) {
        if (!key) {
            throw new Error('Key must be defined');
        }
        let jwkKey = undefined;
        if (!key.kty) {
            jwkKey = {
                kty: 'oct',
                use: this.keyUse,
                k: base64url_1.default(key)
            };
        }
        else {
            jwkKey = key;
        }
        let keyObject = await this._crypto.subtle
            .importKey('jwk', DidKey.normalizeJwk(jwkKey), DidKey.normalizeAlgorithm(this._algorithm), this._exportable, this.setKeyUsage());
        return new KeyObject_1.default(this.keyType, keyObject);
    }
    // Generate an oct key and return a key object
    async generateOctKey() {
        let keyObject = await this._crypto.subtle.generateKey(DidKey.normalizeAlgorithm(this._algorithm), this._exportable, this.setKeyUsage());
        return new KeyObject_1.default(this.keyType, keyObject);
    }
    // Generate a key pair and return a key object
    async generateKeyPair() {
        let keyObject = await this._crypto.subtle.generateKey(DidKey.normalizeAlgorithm(this._algorithm), this._exportable, this.setKeyUsage());
        return new KeyObject_1.default(this.keyType, keyObject);
    }
}
exports.default = DidKey;
//# sourceMappingURL=DidKey.js.map